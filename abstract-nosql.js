// Generated by CoffeeScript 1.8.0
(function() {
  var AbstractChainedBatch, AbstractError, AbstractIterator, AbstractNoSQL, AbstractObject, CloseError, Codec, Errors, InvalidArgumentError, NoSqlStream, NotImplementedError, OpenError, ReadStream, WriteStream, inherits, isString, setImmediate, utf8ByteLength, util, xtend;

  xtend = require("xtend");

  try {
    NoSqlStream = require("nosql-stream");
  } catch (_error) {}

  if (NoSqlStream) {
    ReadStream = NoSqlStream.ReadStream;
  }

  if (NoSqlStream) {
    WriteStream = NoSqlStream.WriteStream;
  }

  AbstractObject = require("abstract-object");

  util = require("abstract-object/lib/util");

  Codec = require("buffer-codec");

  utf8ByteLength = Codec.getByteLen;

  Errors = require("./abstract-error");

  try {
    AbstractIterator = require("abstract-iterator");
  } catch (_error) {}

  AbstractChainedBatch = require("./abstract-chained-batch");

  setImmediate = global.setImmediate || process.nextTick;

  AbstractError = Errors.AbstractError;

  NotImplementedError = Errors.NotImplementedError;

  InvalidArgumentError = Errors.InvalidArgumentError;

  OpenError = Errors.OpenError;

  CloseError = Errors.CloseError;

  inherits = util.inherits;

  isString = util.isString;

  module.exports = AbstractNoSQL = (function() {
    inherits(AbstractNoSQL, AbstractObject);

    function AbstractNoSQL() {
      AbstractNoSQL.__super__.constructor.apply(this, arguments);
    }

    AbstractNoSQL.prototype.init = function(location) {
      if (location && typeof location !== "string") {
        throw new InvalidArgumentError("constructor requires a location string argument");
      }
      return this.location = location;
    };

    AbstractNoSQL.prototype.__defineGetter__("opened", function() {
      return !!this._opened;
    });

    AbstractNoSQL.prototype.setOpened = function(aValue, options) {
      if (aValue) {
        this._opened = true;
        if (options) {
          this._options = options;
        }
        this.emit("ready");
        return this.emit("open");
      } else {
        this._opened = false;
        return this.emit("closed");
      }
    };

    AbstractNoSQL.prototype.isExistsSync = function(key, options) {
      var err, result;
      if (options == null) {
        options = {};
      }
      if (!this._isBuffer(key)) {
        key = String(key);
      }
      if (this._isExistsSync) {
        result = this._isExistsSync(key, options);
        return result;
      } else if (this._getSync) {
        try {
          this._getSync(key, options);
          return true;
        } catch (_error) {
          err = _error;
          if (AbstractError.isNotFound(err)) {
            return false;
          } else {
            throw err;
          }
        }
      }
      throw new NotImplementedError();
    };

    AbstractNoSQL.prototype.isExistSync = AbstractNoSQL.prototype.isExistsSync;

    AbstractNoSQL.prototype.getSync = function(key, options) {
      var err, result;
      if (this._getSync) {
        if (options == null) {
          options = {};
        }
        if (err = this._checkKey(key, "key")) {
          throw err;
        }
        if (!this._isBuffer(key)) {
          key = String(key);
        }
        result = this._getSync(key, options);
        return result;
      }
      throw new NotImplementedError();
    };

    AbstractNoSQL.prototype.getBufferSync = function(key, destBuffer, options) {
      var result;
      if (this._getBufferSync) {
        if (options == null) {
          options = {};
        }
        if (options.offset == null) {
          options.offset = 0;
        }
        result = this._getBufferSync(key, destBuffer, options);
        return result;
      }
      throw new NotImplementedError();
    };

    AbstractNoSQL.prototype.mGetSync = function(keys, options) {
      var arr, i, needKeyName, result;
      if (this._mGetSync) {
        if (options == null) {
          options = {};
        }
        options.raiseError = options.raiseError !== false;
        needKeyName = options.keys;
        arr = this._mGetSync(keys, options);
        i = 0;
        result = [];
        while (i < arr.length) {
          if (needKeyName !== false) {
            result.push({
              key: arr[i],
              value: arr[++i]
            });
          } else {
            result.push(arr[i]);
          }
          i++;
        }
        return result;
      }
      throw new NotImplementedError();
    };

    AbstractNoSQL.prototype.putSync = function(key, value, options) {
      var result;
      if (this._putSync) {
        if (options == null) {
          options = {};
        }
        result = this._putSync(key, value, options);
        return result;
      }
      throw new NotImplementedError();
    };

    AbstractNoSQL.prototype.delSync = function(key, options) {
      var result;
      if (this._delSync) {
        if (options == null) {
          options = {};
        }
        result = this._delSync(key, options);
        return result;
      }
      throw new NotImplementedError();
    };

    AbstractNoSQL.prototype.batchSync = function(operations, options) {
      var e, err, result, _i, _len;
      if (this._batchSync) {
        if (options == null) {
          options = {};
        }
        if (!Array.isArray(operations)) {
          throw new InvalidArgumentError("batch(operations) requires an array argument");
        }
        for (_i = 0, _len = operations.length; _i < _len; _i++) {
          e = operations[_i];
          if (typeof e !== "object") {
            continue;
          }
          if (err = this._checkKey(e.type, "type")) {
            throw err;
          }
          if (err = this._checkKey(e.key, "key")) {
            throw err;
          }
        }
        result = this._batchSync(operations, options);
        return result;
      }
      throw new NotImplementedError();
    };

    AbstractNoSQL.prototype.approximateSizeSync = function(start, end) {
      var result;
      if (this._approximateSizeSync) {
        if ((start == null) || (end == null)) {
          throw new InvalidArgumentError("approximateSize() requires valid `start`, `end` arguments");
        }
        if (!this._isBuffer(start)) {
          start = String(start);
        }
        if (!this._isBuffer(end)) {
          end = String(end);
        }
        result = this._approximateSizeSync(start, end);
        return result;
      }
      throw new NotImplementedError();
    };

    AbstractNoSQL.prototype.openSync = function(options) {
      var result;
      if (this._openSync) {
        if (options == null) {
          options = this._options || {};
        }
        options.createIfMissing = options.createIfMissing !== false;
        options.errorIfExists = !!options.errorIfExists;
        this.emit("opening", options);
        result = this._openSync(options);
        if (result) {
          this.setOpened(true, options);
        }
        if (result) {
          result = this;
        }
        return result;
      }
      throw new NotImplementedError();
    };

    AbstractNoSQL.prototype.closeSync = function() {
      var result;
      if (this._closeSync) {
        this.emit("closing");
        result = this._closeSync();
        if (result) {
          this.setOpened(false);
        }
        return result;
      }
      throw new NotImplementedError();
    };

    AbstractNoSQL.prototype._open = function(options, callback) {
      var that;
      that = this;
      if (this._openSync) {
        return setImmediate(function() {
          var err, result;
          result = void 0;
          try {
            result = that._openSync(options);
          } catch (_error) {
            err = _error;
            callback(err);
            return;
          }
          if (result) {
            return callback(null, result);
          } else {
            return callback(new OpenError("can not open database."));
          }
        });
      } else {
        return setImmediate(callback);
      }
    };

    AbstractNoSQL.prototype._close = function(callback) {
      var that;
      that = this;
      if (this._closeSync) {
        return setImmediate(function() {
          var err, result;
          result = void 0;
          try {
            result = that._closeSync();
          } catch (_error) {
            err = _error;
            callback(err);
            return;
          }
          if (result) {
            return callback(null, result);
          } else {
            return callback(new CloseError("can not close database."));
          }
        });
      } else {
        return setImmediate(callback);
      }
    };

    AbstractNoSQL.prototype._isExists = function(key, options, callback) {
      var that;
      that = this;
      if (this._isExistsSync) {
        return setImmediate(function() {
          var err, result;
          result = void 0;
          try {
            result = that._isExistsSync(key, options);
          } catch (_error) {
            err = _error;
            callback(err);
            return;
          }
          return callback(null, result);
        });
      } else {
        return this._get(key, options, function(err, value) {
          if (err) {
            if (AbstractError.isNotFound(err)) {
              return callback(null, false);
            } else {
              return callback(err);
            }
          } else {
            return callback(null, true);
          }
        });
      }
    };

    AbstractNoSQL.prototype._getBuffer = function(key, destBuffer, options, callback) {
      var that;
      that = this;
      if (this._getSync || this._getBufferSync !== AbstractNoSQL.prototype._getBufferSync) {
        return setImmediate(function() {
          var err, result;
          result = void 0;
          try {
            result = that._getBufferSync(key, destBuffer, options);
          } catch (_error) {
            err = _error;
            callback(err);
            return;
          }
          return callback(null, result);
        });
      } else if (this._get) {
        return this._get(key, options, function(err, value) {
          var result;
          if (err) {
            return callback(err);
          }
          result = utf8ByteLength(value);
          if (destBuffer) {
            result = Math.min(result, destBuffer.length);
            if (result) {
              result = destBuffer.write(value, options.offset, result);
            }
          }
          return callback(null, result);
        });
      } else {
        return setImmediate(callback);
      }
    };

    AbstractNoSQL.prototype._getBufferSync = function(key, destBuffer, options) {
      var result, value;
      if (this._getSync) {
        value = this._getSync(key, options);
        result = utf8ByteLength(value);
        if (destBuffer) {
          result = Math.min(result, destBuffer.length);
          if (result) {
            result = destBuffer.write(value, options.offset, result);
          }
        }
        return result;
      } else {
        throw new NotImplementedError('_mGetSync: _getSync is not implemented.');
      }
    };

    AbstractNoSQL.prototype._mGetSync = function(keys, options) {
      var err, key, needKeyName, raiseError, result, value, _i, _len;
      if (this._getSync) {
        result = [];
        needKeyName = options.keys;
        raiseError = options.raiseError;
        options.asBuffer = options.asBuffer === true;
        for (_i = 0, _len = keys.length; _i < _len; _i++) {
          key = keys[_i];
          try {
            value = this._getSync(key, options);
          } catch (_error) {
            err = _error;
            if (raiseError) {
              throw err;
            }
            value = void 0;
          }
          if (needKeyName !== false) {
            result.push(key, value);
          } else {
            result.push(value);
          }
        }
        return result;
      } else {
        throw new NotImplementedError('_mGetSync: _getSync is not implemented.');
      }
    };

    AbstractNoSQL.prototype._mGet = function(keys, options, callback) {
      var i, needKeyName, raiseError, readNext, result, that;
      that = this;
      if (this._getSync || this._mGetSync !== AbstractNoSQL.prototype._mGetSync) {
        return setImmediate(function() {
          var err, result;
          result = void 0;
          try {
            result = that._mGetSync(keys, options);
          } catch (_error) {
            err = _error;
            callback(err);
            return;
          }
          return callback(null, result);
        });
      } else if (keys.length > 0 && this._get) {
        result = [];
        i = 0;
        needKeyName = options.keys;
        raiseError = options.raiseError;
        readNext = function(err, value) {
          if (err && raiseError) {
            return callback(err);
          }
          if (needKeyName !== false) {
            result.push(keys[i], value);
          } else {
            result.push(value);
          }
          i++;
          if (i >= keys.length) {
            return callback(null, result);
          }
          return that._get(keys[i], options, readNext);
        };
        return this._get(keys[i], options, readNext);
      } else {
        return setImmediate(callback);
      }
    };

    AbstractNoSQL.prototype._get = function(key, options, callback) {
      var that;
      that = this;
      if (this._getSync) {
        return setImmediate(function() {
          var err, result;
          result = void 0;
          try {
            result = that._getSync(key, options);
          } catch (_error) {
            err = _error;
            callback(err);
            return;
          }
          return callback(null, result);
        });
      } else {
        return setImmediate(callback);
      }
    };

    AbstractNoSQL.prototype._put = function(key, value, options, callback) {
      var that;
      that = this;
      if (this._putSync) {
        return setImmediate(function() {
          var err, result;
          result = void 0;
          try {
            result = that._putSync(key, value, options);
          } catch (_error) {
            err = _error;
            callback(err);
            return;
          }
          return callback(null, result);
        });
      } else {
        return setImmediate(callback);
      }
    };

    AbstractNoSQL.prototype._del = function(key, options, callback) {
      var that;
      that = this;
      if (this._delSync) {
        return setImmediate(function() {
          var err, result;
          result = void 0;
          try {
            result = that._delSync(key, options);
          } catch (_error) {
            err = _error;
            callback(err);
            return;
          }
          return callback(null, result);
        });
      } else {
        return setImmediate(callback);
      }
    };

    AbstractNoSQL.prototype._batch = function(array, options, callback) {
      var that;
      that = this;
      if (this._batchSync) {
        return setImmediate(function() {
          var err, result;
          result = void 0;
          try {
            result = that._batchSync(array, options);
          } catch (_error) {
            err = _error;
            callback(err);
            return;
          }
          return callback(null, result);
        });
      } else {
        return setImmediate(callback);
      }
    };

    AbstractNoSQL.prototype._approximateSize = function(start, end, callback) {
      var that;
      that = this;
      if (this._approximateSizeSync) {
        return setImmediate(function() {
          var err, result;
          result = void 0;
          try {
            result = that._approximateSizeSync(start, end);
          } catch (_error) {
            err = _error;
            callback(err);
            return;
          }
          return callback(null, result);
        });
      } else {
        return setImmediate(callback);
      }
    };

    AbstractNoSQL.prototype.openAsync = function(options, callback) {
      var that;
      if (options == null) {
        options = {};
      }
      options.createIfMissing = options.createIfMissing !== false;
      options.errorIfExists = !!options.errorIfExists;
      that = this;
      this.emit("opening", options);
      return this._open(options, function(err, result) {
        if (err == null) {
          that.setOpened(true, options);
        }
        return callback(err, result);
      });
    };

    AbstractNoSQL.prototype.open = function(options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = void 0;
      }
      if (callback) {
        return this.openAsync(options, callback);
      } else {
        return this.openSync(options);
      }
    };

    AbstractNoSQL.prototype.close = function(callback) {
      var that;
      if (callback) {
        if (typeof callback === "function") {
          that = this;
          this.emit("closing");
          return this._close(function(err, result) {
            if (err == null) {
              that.setOpened(false);
            }
            return callback(err, result);
          });
        } else {
          throw new InvalidArgumentError("close() requires callback function argument");
        }
      } else {
        return this.closeSync();
      }
    };

    AbstractNoSQL.prototype.isExistsAsync = function(key, options, callback) {
      if (options == null) {
        options = {};
      }
      if (!this._isBuffer(key)) {
        key = String(key);
      }
      return this._isExists(key, options, callback);
    };

    AbstractNoSQL.prototype.isExists = function(key, options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = {};
      } else {

      }
      if (callback) {
        return this.isExistsAsync(key, options, callback);
      } else {
        return this.isExistsSync(key, options);
      }
    };

    AbstractNoSQL.prototype.isExist = AbstractNoSQL.prototype.isExists;

    AbstractNoSQL.prototype.getBufferAsync = function(key, destBuffer, options, callback) {
      if (options == null) {
        options = {};
      }
      if (options.offset == null) {
        options.offset = 0;
      }
      return this._getBuffer(key, destBuffer, options, callback);
    };

    AbstractNoSQL.prototype.getBuffer = function(key, destBuffer, options, callback) {
      var err;
      err = void 0;
      if (typeof options === "function") {
        callback = options;
        options = {};
      }
      if (callback) {
        return this.getBufferAsync(key, destBuffer, options, callback);
      } else {
        return this.getBufferSync(key, destBuffer, options);
      }
    };

    AbstractNoSQL.prototype.mGetAsync = function(keys, options, callback) {
      var needKeyName;
      if (options == null) {
        options = {};
      }
      options.asBuffer = options.asBuffer === true;
      options.raiseError = options.raiseError !== false;
      needKeyName = options.keys !== false;
      return this._mGet(keys, options, function(err, arr) {
        var i, result;
        if (err) {
          return callback(err);
        }
        if (needKeyName) {
          i = 0;
          result = [];
          while (i < arr.length) {
            result.push({
              key: arr[i],
              value: arr[++i]
            });
            i++;
          }
        } else {
          result = arr;
        }
        return callback(null, result);
      });
    };

    AbstractNoSQL.prototype.mGet = function(keys, options, callback) {
      var err;
      err = void 0;
      if (typeof options === "function") {
        callback = options;
        options = {};
      } else {

      }
      if (callback) {
        return this.mGetAsync(keys, options, callback);
      } else {
        return this.mGetSync(keys, options);
      }
    };

    AbstractNoSQL.prototype.getAsync = function(key, options, callback) {
      var err;
      if (options == null) {
        options = {};
      }
      if (err = this._checkKey(key, "key")) {
        return callback(err);
      }
      if (!this._isBuffer(key)) {
        key = String(key);
      }
      options.asBuffer = options.asBuffer !== false;
      return this._get(key, options, callback);
    };

    AbstractNoSQL.prototype.get = function(key, options, callback) {
      var err;
      err = void 0;
      if (typeof options === "function") {
        callback = options;
        options = {};
      }
      if (callback) {
        return this.getAsync(key, options, callback);
      } else {
        return this.getSync(key, options);
      }
    };

    AbstractNoSQL.prototype.putAsync = function(key, value, options, callback) {
      var err;
      if (options == null) {
        options = {};
      }
      if (err = this._checkKey(key, "key", this._isBuffer)) {
        return callback(err);
      }
      if (!this._isBuffer(key)) {
        key = String(key);
      }
      if ((value != null) && !this._isBuffer(value) && !process.browser) {
        value = String(value);
      }
      return this._put(key, value, options, callback);
    };

    AbstractNoSQL.prototype.put = function(key, value, options, callback) {
      var err;
      err = void 0;
      if (typeof options === "function") {
        callback = options;
        options = {};
      }
      if (callback) {
        return this.putAsync(key, value, options, callback);
      } else {
        return this.putSync(key, value, options);
      }
    };

    AbstractNoSQL.prototype.delAsync = function(key, options, callback) {
      var err;
      if (options == null) {
        options = {};
      }
      if (err = this._checkKey(key, "key", this._isBuffer)) {
        return callback(err);
      }
      if (!this._isBuffer(key)) {
        key = String(key);
      }
      return this._del(key, options, callback);
    };

    AbstractNoSQL.prototype.del = function(key, options, callback) {
      var err;
      err = void 0;
      if (typeof options === "function") {
        callback = options;
        options = {};
      }
      if (callback) {
        return this.delAsync(key, options, callback);
      } else {
        return this.delSync(key, options);
      }
    };

    AbstractNoSQL.prototype.batchAsync = function(array, options, callback) {
      var e, err, vError, _i, _len;
      if (options == null) {
        options = {};
      }
      if (!Array.isArray(array)) {
        vError = new InvalidArgumentError("batch(array) requires an array argument");
        return callback(vError);
      }
      for (_i = 0, _len = array.length; _i < _len; _i++) {
        e = array[_i];
        if (typeof e !== "object") {
          continue;
        }
        if (err = this._checkKey(e.type, "type")) {
          return callback(err);
        }
        if (err = this._checkKey(e.key, "key")) {
          return callback(err);
        }
      }
      return this._batch(array, options, callback);
    };

    AbstractNoSQL.prototype.batch = function(array, options, callback) {
      if (!arguments.length) {
        return this._chainedBatch();
      }
      if (typeof options === "function") {
        callback = options;
        options = {};
      }
      if (typeof array === "function") {
        callback = array;
      }
      if (callback) {
        return this.batchAsync(array, options, callback);
      } else {
        return this.batchSync(array, options);
      }
    };

    AbstractNoSQL.prototype.approximateSizeAsync = function(start, end, callback) {
      if (!this._isBuffer(start)) {
        start = String(start);
      }
      if (!this._isBuffer(end)) {
        end = String(end);
      }
      return this._approximateSize(start, end, callback);
    };

    AbstractNoSQL.prototype.approximateSize = function(start, end, callback) {
      if ((start == null) || (end == null) || typeof start === "function" || typeof end === "function") {
        throw new InvalidArgumentError("approximateSize() requires valid `start`, `end` and `callback`(for async) arguments");
      }
      if (callback) {
        return this.approximateSizeAsync(start, end, callback);
      } else {
        return this.approximateSizeSync(start, end);
      }
    };

    AbstractNoSQL.prototype.IteratorClass = AbstractIterator;

    AbstractNoSQL.prototype.iterator = function(options) {
      if (typeof options !== "object") {
        options = {};
      }
      if (this.IteratorClass) {
        return new this.IteratorClass(this, options);
      } else if (typeof this._iterator === "function") {
        console.error("_iterator is deprecated. please use the IteratorClass instead.");
        return this._iterator(options);
      }
      throw new NotImplementedError();
    };

    AbstractNoSQL.prototype._chainedBatch = function() {
      return new AbstractChainedBatch(this);
    };

    AbstractNoSQL.prototype._isBuffer = function(obj) {
      return Buffer.isBuffer(obj);
    };

    AbstractNoSQL.prototype._checkKey = function(obj, type) {
      if (obj == null) {
        return new InvalidArgumentError(type + " cannot be `null` or `undefined`");
      }
      if (this._isBuffer(obj)) {
        if (obj.length === 0) {
          return new InvalidArgumentError(type + " cannot be an empty Buffer");
        }
      } else {
        if (String(obj) === "") {
          return new InvalidArgumentError(type + " cannot be an empty String");
        }
      }
    };

    AbstractNoSQL.prototype.isOpen = function() {
      return !!this._opened;
    };

    AbstractNoSQL.prototype.readStream = function(options, makeData) {
      var opt;
      if (ReadStream) {
        opt = xtend(this._options, options);
        return ReadStream(this, opt, makeData);
      } else {
        return console.error("please `npm install nosql-stream` first");
      }
    };

    AbstractNoSQL.prototype.createReadStream = AbstractNoSQL.prototype.readStream;

    AbstractNoSQL.prototype.valueStream = function(options, makeData) {
      var opt;
      opt = xtend(options);
      opt.keys = false;
      return this.readStream(opt, makeData);
    };

    AbstractNoSQL.prototype.createValueStream = AbstractNoSQL.prototype.valueStream;

    AbstractNoSQL.prototype.keyStream = function(options, makeData) {
      var opt;
      opt = xtend(options);
      opt.values = false;
      return this.readStream(opt, makeData);
    };

    AbstractNoSQL.prototype.createKeyStream = AbstractNoSQL.prototype.keyStream;

    AbstractNoSQL.prototype.writeStream = function(options) {
      var opt;
      if (WriteStream) {
        opt = xtend(this._options, options);
        return WriteStream(this, opt);
      } else {
        return console.error("please `npm install nosql-stream` first");
      }
    };

    AbstractNoSQL.prototype.createWriteStream = AbstractNoSQL.prototype.writeStream;

    return AbstractNoSQL;

  })();

  module.exports.AbstractNoSQL = AbstractNoSQL;

  module.exports.__defineGetter__("AbstractLevelDOWN", function() {
    console.error("AbstractLevelDOWN is deprecated. use AbstractNoSQL instead.");
    return AbstractNoSQL;
  });

  module.exports.__defineGetter__("AbstractIterator", function() {
    console.error("AbstractIterator is deprecated. it's moved to abstract-iterator.");
    if (!AbstractIterator) {
      console.error("first `npm install abstract-iterator`");
    }
    return AbstractIterator;
  });

  module.exports.AbstractChainedBatch = AbstractChainedBatch;

}).call(this);
